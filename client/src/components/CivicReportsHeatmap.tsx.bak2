import React, { useEffect, useState } from 'react';
import { MapContainer, TileLayer, Marker, Popup, useMap } from 'react-leaflet';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import 'leaflet.heat';
import { useImpersonation } from '@/hooks/useImpersonation';
import { useCivicReports } from '@/contexts/CivicReportsContext';

// Fix per icone marker Leaflet
import icon from 'leaflet/dist/images/marker-icon.png';
import iconShadow from 'leaflet/dist/images/marker-shadow.png';

const DefaultIcon = L.icon({
  iconUrl: icon,
  shadowUrl: iconShadow,
  iconSize: [25, 41],
  iconAnchor: [12, 41],
});
L.Marker.prototype.options.icon = DefaultIcon;

interface CivicReport {
  id: number;
  type: string;
  description: string;
  lat: string | number;
  lng: string | number;
  status: string;
  priority?: string;
  created_at?: string;
  comune_id?: number;
}

// Coordinate centri comuni
const COMUNI_COORDS: Record<number, { lat: number; lng: number; nome: string }> = {
  1: { lat: 42.7635, lng: 11.1126, nome: 'Grosseto' },
  6: { lat: 44.4949, lng: 11.3426, nome: 'Bologna' },
  7: { lat: 44.4898, lng: 11.0123, nome: 'Vignola' },
  8: { lat: 44.6471, lng: 10.9252, nome: 'Modena' },
  9: { lat: 44.7842, lng: 10.8847, nome: 'Carpi' },
};

// Centro default Italia
const DEFAULT_CENTER = { lat: 42.5, lng: 12.5 };
const DEFAULT_ZOOM = 6;

// Componente per centrare automaticamente la mappa sui reports o sul comune
function MapCenterUpdater({ reports, comuneId }: { reports: CivicReport[]; comuneId: number | null }) {
  const map = useMap();
  
  useEffect(() => {
    if (!map) return;
    
    // Se ci sono reports con coordinate, centra su di loro
    const validReports = reports.filter(r => r.lat && r.lng);
    if (validReports.length > 0) {
      const avgLat = validReports.reduce((sum, r) => 
        sum + (typeof r.lat === 'string' ? parseFloat(r.lat) : r.lat), 0) / validReports.length;
      const avgLng = validReports.reduce((sum, r) => 
        sum + (typeof r.lng === 'string' ? parseFloat(r.lng) : r.lng), 0) / validReports.length;
      
      map.flyTo([avgLat, avgLng], 17, { duration: 1.5 });
      return;
    }
    
    // Altrimenti centra sul comune se specificato
    if (comuneId && COMUNI_COORDS[comuneId]) {
      const coords = COMUNI_COORDS[comuneId];
      map.flyTo([coords.lat, coords.lng], 14, { duration: 1.5 });
      return;
    }
    
    // Default: vista Italia
    map.flyTo([DEFAULT_CENTER.lat, DEFAULT_CENTER.lng], DEFAULT_ZOOM, { duration: 1 });
  }, [map, reports, comuneId]);
  
  return null;
}

// Componente interno per aggiungere la heatmap
function HeatmapLayer({ reports }: { reports: CivicReport[] }) {
  const map = useMap();
  
  useEffect(() => {
    if (!map || !reports || reports.length === 0) return;
    
    const heatData: [number, number, number][] = reports
      .filter(r => r.lat && r.lng)
      .map(r => {
        const lat = typeof r.lat === 'string' ? parseFloat(r.lat) : r.lat;
        const lng = typeof r.lng === 'string' ? parseFloat(r.lng) : r.lng;
        let intensity = 0.5;
        if (r.priority === 'URGENT') intensity = 1.0;
        if (r.status === 'pending') intensity += 0.3;
        return [lat, lng, Math.min(intensity, 1.0)];
      });
    
    if (heatData.length === 0) return;
    
    const heatLayer = (L as any).heatLayer(heatData, {
      radius: 40,
      blur: 30,
      maxZoom: 18,
      max: 1.0,
      gradient: {
        0.0: '#00ff00',
        0.25: '#adff2f',
        0.5: '#ffff00',
        0.75: '#ffa500',
        1.0: '#ff0000'
      }
    }).addTo(map);
    
    return () => {
      if (map && heatLayer) {
        map.removeLayer(heatLayer);
      }
    };
  }, [map, reports]);
  
  return null;
}

// Icone personalizzate per tipo segnalazione - 15px
const getMarkerIcon = (type: string, status: string) => {
  const emoji: Record<string, string> = {
    'Degrado': 'üèöÔ∏è',
    'Rifiuti': 'üóëÔ∏è',
    'Illuminazione': 'üí°',
    'Sicurezza': 'üîí',
    'Buche': 'üï≥Ô∏è',
    'Microcriminalit√†': '‚ö†Ô∏è',
    'Abusivismo': 'üö´',
    'Altro': 'üìç'
  };
  
  const icon = emoji[type] || 'üìç';
  const bgColor = status === 'resolved' ? '#22c55e' : status === 'in_progress' ? '#f59e0b' : '#ef4444';
  
  return L.divIcon({
    html: `<div style="
      background: ${bgColor};
      border-radius: 50%;
      width: 15px;
      height: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 9px;
      border: 1px solid white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    ">${icon}</div>`,
    className: 'custom-marker',
    iconSize: [15, 15],
    iconAnchor: [7, 7],
  });
};

// Funzione per calcolare offset a spirale per marker con stesse coordinate
const calculateSpiralOffset = (index: number, total: number): { lat: number; lng: number } => {
  if (total <= 1) return { lat: 0, lng: 0 };
  
  const baseOffset = 0.00008; // ~8 metri
  const angle = (index * 2 * Math.PI) / Math.min(total, 8);
  const ring = Math.floor(index / 8);
  const radius = baseOffset * (ring + 1);
  
  return {
    lat: Math.cos(angle) * radius,
    lng: Math.sin(angle) * radius
  };
};

// Raggruppa reports per coordinate
const groupByCoordinates = (reports: CivicReport[]): Map<string, CivicReport[]> => {
  const groups = new Map<string, CivicReport[]>();
  
  reports.forEach(report => {
    if (!report.lat || !report.lng) return;
    const key = `${report.lat}_${report.lng}`;
    if (!groups.has(key)) {
      groups.set(key, []);
    }
    groups.get(key)!.push(report);
  });
  
  return groups;
};

export default function CivicReportsHeatmap() {
  const [reports, setReports] = useState<CivicReport[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // Usa il sistema di impersonificazione per ottenere il comune_id
  const { comuneId, isImpersonating, comuneNome } = useImpersonation();
  const { selectedReport } = useCivicReports();
  const currentComuneId = comuneId ? parseInt(comuneId) : null;
  
  // Fetch segnalazioni filtrate per comune
  useEffect(() => {
    const fetchReports = async () => {
      setLoading(true);
      setError(null);
      
      try {
        // Costruisci URL con filtro comune se in impersonificazione
        let url = 'https://api.mio-hub.me/api/civic-reports/stats';
        if (currentComuneId) {
          url += `?comune_id=${currentComuneId}`;
        }
        
        console.log('[CivicReportsHeatmap] Fetching:', url, '| Comune:', comuneNome || 'Tutti');
        
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.success && data.data?.recent) {
          setReports(data.data.recent);
          console.log('[CivicReportsHeatmap] Caricate', data.data.recent.length, 'segnalazioni per', comuneNome || 'tutti i comuni');
        } else {
          setReports([]);
        }
      } catch (err) {
        console.error('[CivicReportsHeatmap] Errore fetch:', err);
        setError('Errore caricamento segnalazioni');
        setReports([]);
      } finally {
        setLoading(false);
      }
    };
    
    fetchReports();
  }, [currentComuneId, comuneNome]);
  
  // Raggruppa e calcola offset per marker
  const groupedReports = groupByCoordinates(reports);
  const markersWithOffset: Array<CivicReport & { offsetLat: number; offsetLng: number }> = [];
  
  groupedReports.forEach((group) => {
    group.forEach((report, index) => {
      const offset = calculateSpiralOffset(index, group.length);
      markersWithOffset.push({
        ...report,
        offsetLat: offset.lat,
        offsetLng: offset.lng
      });
    });
  });
  
  const validReports = reports.filter(r => r.lat && r.lng);
  
  // Determina centro iniziale
  const getInitialCenter = (): [number, number] => {
    if (currentComuneId && COMUNI_COORDS[currentComuneId]) {
      return [COMUNI_COORDS[currentComuneId].lat, COMUNI_COORDS[currentComuneId].lng];
    }
    return [DEFAULT_CENTER.lat, DEFAULT_CENTER.lng];
  };
  
  const getInitialZoom = (): number => {
    return currentComuneId ? 14 : DEFAULT_ZOOM;
  };

  if (loading) {
    return (
      <div className="bg-slate-800/50 rounded-xl p-4 border border-slate-700">
        <div className="flex items-center justify-between mb-3">
          <h3 className="text-white font-medium flex items-center gap-2">
            üî• Mappa Termica Segnalazioni
            {comuneNome && <span className="text-cyan-400 text-sm">({comuneNome})</span>}
          </h3>
        </div>
        <div className="h-[600px] flex items-center justify-center bg-slate-900/50 rounded-lg">
          <div className="text-slate-400 animate-pulse">Caricamento mappa termica...</div>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-slate-800/50 rounded-xl p-4 border border-slate-700">
      <div className="flex items-center justify-between mb-3">
        <h3 className="text-white font-medium flex items-center gap-2">
          üî• Mappa Termica Segnalazioni
          {comuneNome && <span className="text-cyan-400 text-sm">({comuneNome})</span>}
        </h3>
        <div className="flex items-center gap-2">
          {isImpersonating && (
            <span className="text-xs text-purple-400 bg-purple-500/20 px-2 py-1 rounded">
              üèõÔ∏è Vista Comune
            </span>
          )}
          {validReports.length > 0 && (
            <span className="text-xs text-emerald-400">‚óè {validReports.length} segnalazioni</span>
          )}
        </div>
      </div>
      
      {error ? (
        <div className="h-[600px] flex items-center justify-center bg-slate-900/50 rounded-lg">
          <div className="text-red-400">{error}</div>
        </div>
      ) : (
        <div className="h-[600px] rounded-lg overflow-hidden">
          <MapContainer
            center={getInitialCenter()}
            zoom={getInitialZoom()}
            style={{ height: '100%', width: '100%' }}
            scrollWheelZoom={false}
            dragging={true}
            doubleClickZoom={false}
            touchZoom={false}
          >
            <TileLayer
              attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
              url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
            />
            
            <MapCenterUpdater reports={reports} comuneId={currentComuneId} />
            <HeatmapLayer reports={reports} />
            
            {markersWithOffset.map((report) => {
              const lat = (typeof report.lat === 'string' ? parseFloat(report.lat) : report.lat) + report.offsetLat;
              const lng = (typeof report.lng === 'string' ? parseFloat(report.lng) : report.lng) + report.offsetLng;
              
              return (
                <Marker
                  key={report.id}
                  position={[lat, lng]}
                  icon={getMarkerIcon(report.type, report.status)}
                >
                  <Popup>
                    <div className="text-sm">
                      <strong>{report.type}</strong>
                      <p className="text-gray-600 mt-1">{report.description}</p>
                      <p className="text-xs text-gray-500 mt-1">
                        Stato: <span className={
                          report.status === 'resolved' ? 'text-green-600' :
                          report.status === 'in_progress' ? 'text-yellow-600' : 'text-red-600'
                        }>{report.status}</span>
                      </p>
                      {report.created_at && (
                        <p className="text-xs text-gray-400">
                          {new Date(report.created_at).toLocaleDateString('it-IT')}
                        </p>
                      )}
                    </div>
                  </Popup>
                </Marker>
              );
            })}
          </MapContainer>
        </div>
      )}
      
      {!isImpersonating && validReports.length > 0 && (
        <p className="text-xs text-slate-500 mt-2 text-center">
          Vista globale - Seleziona un comune per filtrare le segnalazioni
        </p>
      )}
    </div>
  );
}
