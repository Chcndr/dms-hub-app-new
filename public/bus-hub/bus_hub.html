<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
  <title>DMS ‚Ä¢ BUS HUB - Centro di Controllo Workflow</title>  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="./shared/dms-console.css" />  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
    
    .topbar {
      background: #0f2830;
      color: #d5f0e6;
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    .brand { font-weight: 600; font-size: 16px; }
    .ver { font-size: 12px; opacity: 0.7; }
    
    .app { display: flex; height: calc(100vh - 48px); }
    
    .sidebar {
      width: 380px;
      background: #0f2830;
      color: #d5f0e6;
      overflow-y: auto;
      padding: 20px;
      border-right: 1px solid rgba(213, 240, 230, 0.1);
    }
    
    .main-content {
      flex: 1;
      background: #0b1c26;
      overflow-y: auto;
      padding: 20px;
    }
    
    .section {
      margin-bottom: 24px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(213, 240, 230, 0.1);
    }
    .section:last-child { border-bottom: none; }
    
    h2 {
      color: #4CAF50;
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 16px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    h3 {
      color: #4CAF50;
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    button, .btn {
      background: #1a9e9e;
      color: white;
      border: none;
      padding: 12px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      width: 100%;
      margin-bottom: 8px;
      transition: background 0.2s;
      text-decoration: none;
      display: block;
      text-align: center;
    }
    button:hover, .btn:hover { background: #158787; }
    button:active, .btn:active { background: #106d6d; }
    
    button.danger, .btn.danger {
      background: #d32f2f;
    }
    button.danger:hover, .btn.danger:hover { background: #b71c1c; }
    
    button.secondary, .btn.secondary {
      background: #455a64;
    }
    button.secondary:hover, .btn.secondary:hover { background: #37474f; }
    
    button.success, .btn.success {
      background: #4CAF50;
    }
    button.success:hover, .btn.success:hover { background: #388e3c; }
    
    .workflow-step {
      background: #1a4a5a;
      border-left: 4px solid #455a64;
      padding: 12px;
      margin-bottom: 12px;
      border-radius: 4px;
      transition: all 0.3s;
    }
    
    .workflow-step.completed {
      border-left-color: #4CAF50;
      background: #1a5a4a;
    }
    
    .workflow-step.in-progress {
      border-left-color: #ff9800;
      background: #5a4a1a;
    }
    
    .workflow-step.waiting {
      border-left-color: #455a64;
      opacity: 0.6;
    }
    
    .workflow-step-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .workflow-step-title {
      font-weight: 600;
      font-size: 14px;
    }
    
    .workflow-step-status {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 3px;
      background: rgba(0,0,0,0.3);
    }
    
    .workflow-step-desc {
      font-size: 12px;
      opacity: 0.8;
      margin-bottom: 8px;
    }
    
    .bus-data-item {
      background: #1a4a5a;
      padding: 10px;
      margin-bottom: 8px;
      border-radius: 4px;
      font-size: 13px;
    }
    
    .bus-data-key {
      font-weight: 600;
      color: #4fc3a0;
      margin-bottom: 4px;
    }
    
    .bus-data-info {
      font-size: 11px;
      opacity: 0.7;
      display: flex;
      justify-content: space-between;
    }
    
    .bus-data-empty {
      text-align: center;
      padding: 20px;
      opacity: 0.5;
      font-size: 13px;
    }
    
    .card {
      background: #0f2330;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    
    .card h3 {
      margin-top: 0;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
      margin-top: 16px;
    }
    
    .stat-card {
      background: #1a4a5a;
      padding: 16px;
      border-radius: 6px;
      text-align: center;
    }
    
    .stat-value {
      font-size: 32px;
      font-weight: 700;
      color: #4CAF50;
      margin-bottom: 4px;
    }
    
    .stat-label {
      font-size: 12px;
      opacity: 0.8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .progress-bar {
      background: #1a4a5a;
      height: 8px;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 12px;
    }
    
    .progress-bar-fill {
      background: linear-gradient(90deg, #4CAF50, #1a9e9e);
      height: 100%;
      transition: width 0.5s ease;
    }
    
    #preview-map {
      width: 100%;
      height: 500px;
      border-radius: 8px;
      margin-top: 12px;
    }
    
    .btn-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    
    .alert {
      padding: 12px;
      border-radius: 4px;
      margin-bottom: 16px;
      font-size: 13px;
    }
    
    .alert-info {
      background: rgba(33, 150, 243, 0.2);
      border-left: 4px solid #2196F3;
      color: #b3d9ff;
    }
    
    .alert-warning {
      background: rgba(255, 152, 0, 0.2);
      border-left: 4px solid #ff9800;
      color: #ffd699;
    }
    
    .alert-success {
      background: rgba(76, 175, 80, 0.2);
      border-left: 4px solid #4CAF50;
      color: #c8e6c9;
    }
    
    .checkpoint-item {
      background: #1a4a5a;
      padding: 12px;
      margin-bottom: 10px;
      border-radius: 6px;
      border-left: 4px solid #4CAF50;
    }
    
    .checkpoint-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    
    .checkpoint-title {
      font-weight: 600;
      font-size: 14px;
      color: #4fc3a0;
    }
    
    .checkpoint-time {
      font-size: 11px;
      opacity: 0.7;
    }
    
    .checkpoint-desc {
      font-size: 12px;
      opacity: 0.8;
      margin-bottom: 8px;
    }
    
    .checkpoint-actions {
      display: flex;
      gap: 6px;
    }
    
    .checkpoint-actions button {
      padding: 6px 12px;
      font-size: 12px;
      margin: 0;
    }
    
    .checkpoint-empty {
      text-align: center;
      padding: 20px;
      opacity: 0.5;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">DMS ‚Ä¢ GEMELLO DIGITALE ‚Äî BUS HUB (Centro di Controllo)</div>
    <div class="ver" id="ver">v1.0</div>
  </header>

  <div class="app">
    <aside class="sidebar">
      <div class="section">
        <h2>üè† Navigazione</h2>
        <a href="../index.html" class="btn secondary">üåç Sito Pubblico DMS HUB</a>
        <a href="../index-grosseto.html" class="btn secondary">üó∫Ô∏è Core Map Grosseto</a>
        <a href="https://dmshubapp-hkvujnro.manus.space/dashboard-pa" class="btn secondary" target="_blank">üìä Dashboard Admin</a>
      </div>

      <div class="section">
        <h2>üéØ Workflow Tools</h2>
        <div style="margin-bottom: 16px;">
          <label for="market-name-input" style="display: block; margin-bottom: 8px; font-size: 14px; font-weight: 500;">
            üè™ Nome Mercato:
          </label>
          <input 
            type="text" 
            id="market-name-input" 
            placeholder="Es: Mercato Settimanale Grosseto" 
            style="width: 100%; padding: 10px; border: 1px solid rgba(213, 240, 230, 0.3); border-radius: 4px; background: #0b1c26; color: #d5f0e6; font-size: 14px;"
          />
        </div>
        <a href="stalls_alpha_tool.html" class="btn" id="btn-png-tool">
          üé® PNG Transparent Tool
        </a>
        <a href="slot_editor_v3_unified.html" class="btn" id="btn-slot-editor">
          üìç Slot Editor v3
        </a>
      </div>

      <div class="section">
        <h2>üîß Gestione Bus</h2>
        <button id="btn-refresh" class="secondary">üîÑ Aggiorna Stato</button>
        <button id="btn-export" class="secondary">üíæ Esporta Progetto</button>
        <button id="btn-export-stalls" class="success">üìç Esporta Solo Posteggi</button>
        <button id="btn-send-to-dms" class="btn" style="background: #8b5cf6;">üì§ Invia a DMS Hub</button>
        <button id="btn-import" class="secondary">üìÇ Importa Progetto</button>
        <button id="btn-clear-all" class="danger">üóëÔ∏è Pulisci Tutto</button>
        <button id="btn-test-data" class="btn" style="background: #f59e0b;">üß™ Inserisci Dati Test</button>
      </div>

      <div class="section">
        <h2>üì¶ Dati nel Bus</h2>
        <div id="bus-data-list">
          <div class="bus-data-empty">Caricamento...</div>
        </div>
      </div>

      <div class="section">
        <h2>üíæ Timeline Progetto</h2>
        <button id="btn-save-checkpoint" class="success">üíæ Salva Checkpoint</button>
        <div id="checkpoint-list" style="margin-top: 12px;">
          <div class="checkpoint-empty">Nessun checkpoint salvato</div>
        </div>
      </div>
    </aside>

    <main class="main-content">
      <div class="card">
        <h3>üìä Dashboard Workflow</h3>
        <div class="alert alert-info" id="workflow-alert">
          Benvenuto nel BUS HUB! Qui puoi monitorare lo stato del workflow e navigare tra i tool.
        </div>
        
        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-value" id="stat-progress">0%</div>
            <div class="stat-label">Completamento</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-steps">0/4</div>
            <div class="stat-label">Step Completati</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-data">0</div>
            <div class="stat-label">Dati nel Bus</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-size">0 KB</div>
            <div class="stat-label">Dimensione Totale</div>
          </div>
        </div>
        
        <div class="progress-bar">
          <div class="progress-bar-fill" id="progress-bar-fill" style="width: 0%"></div>
        </div>
      </div>

      <div class="card">
        <h3>üîÑ Stato Workflow</h3>
        
        <div class="workflow-step" id="step-png">
          <div class="workflow-step-header">
            <div class="workflow-step-title">1Ô∏è‚É£ PNG Transparent Tool</div>
            <div class="workflow-step-status" id="status-png">‚è∏Ô∏è In attesa</div>
          </div>
          <div class="workflow-step-desc">Rimuovi lo sfondo dalla pianta del mercato e salva PNG trasparente</div>
          <a href="stalls_alpha_tool.html" class="btn secondary" style="margin-top: 8px;">Vai al Tool ‚Üí</a>
        </div>

        <div class="workflow-step" id="step-slot">
          <div class="workflow-step-header">
            <div class="workflow-step-title">2Ô∏è‚É£ Slot Editor v3</div>
            <div class="workflow-step-status" id="status-slot">‚è∏Ô∏è In attesa</div>
          </div>
          <div class="workflow-step-desc">Georeferenzia pianta, crea posteggi, marker personalizzati e aree mercato</div>
          <button onclick="goToSlotEditorV3()" class="btn secondary" style="margin-top: 8px;">Vai al Tool ‚Üí</button>
        </div>


      </div>

      <div class="card">
        <h3>üíæ Banca Mappe</h3>
        <div class="workflow-step-desc" style="margin-bottom: 12px;">
          Salva e recupera configurazioni complete di mercati digitalizzati
        </div>
        
        <div style="display: flex; gap: 8px; margin-bottom: 12px;">
          <button id="btn-save-map" class="btn" style="flex: 1;">
            üíæ Salva Configurazione
          </button>
          <button id="btn-load-map" class="btn secondary" style="flex: 1;">
            üìÇ Carica Configurazione
          </button>
        </div>
        
        <div id="saved-maps-list" style="max-height: 200px; overflow-y: auto;">
          <div style="text-align: center; opacity: 0.6; padding: 20px; font-size: 13px;">
            Nessuna configurazione salvata
          </div>
        </div>
      </div>

      <div class="card">
        <h3>üó∫Ô∏è Preview Mappa</h3>
        <div id="preview-map"></div>
      </div>
    </main>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="./shared/dms-bus.js"></script>
  <script src="./shared/dms-console.js"></script>
  <script>
    // Inizializza mappa preview
    const previewMap = L.map('preview-map').setView([42.7633, 11.1117], 17);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 20,
      attribution: '¬© OpenStreetMap'
    }).addTo(previewMap);

    let overlayLayer = null;
    let areaLayer = null;
    let hubLayer = null;
    let centerMarker = null;

    // Funzione per aggiornare lo stato del workflow
    async function updateWorkflowStatus() {
      try {
        // Leggi dati dal bus
        const pngTransparent = await DMSBUS.get('png_transparent');
        const pngMeta = await DMSBUS.getJSON('png_meta');
        const gcp = await DMSBUS.getJSON('gcp');
        const container = await DMSBUS.getJSON('container');
        const areaGeoJSON = await DMSBUS.getJSON('area_geojson');
        const hubGeoJSON = await DMSBUS.getJSON('hub_geojson');
        const stallsGeoJSON = await DMSBUS.getJSON('stalls_geojson');

        // Conta step completati
        let completedSteps = 0;
        let totalData = 0;
        let totalSize = 0;

        // Step 1: PNG Tool
        const step1 = document.getElementById('step-png');
        const status1 = document.getElementById('status-png');
        if (pngTransparent && pngMeta) {
          step1.classList.remove('waiting', 'in-progress');
          step1.classList.add('completed');
          status1.textContent = '‚úÖ Completato';
          completedSteps++;
          totalData += 2;
          totalSize += (pngTransparent?.length || 0) + JSON.stringify(pngMeta || {}).length;
        } else {
          step1.classList.remove('completed', 'in-progress');
          step1.classList.add('waiting');
          status1.textContent = '‚è∏Ô∏è In attesa';
        }

        // Conta dati aggiuntivi
        if (gcp) {
          totalData++;
          totalSize += JSON.stringify(gcp).length;
        }
        if (container) {
          totalData++;
          totalSize += JSON.stringify(container).length;
        }
        if (areaGeoJSON) {
          totalData++;
          totalSize += JSON.stringify(areaGeoJSON).length;
        }
        if (hubGeoJSON) {
          totalData++;
          totalSize += JSON.stringify(hubGeoJSON).length;
        }

        // Step 2: Slot Editor v3
        const step2 = document.getElementById('step-slot');
        const status2 = document.getElementById('status-slot');
        if (stallsGeoJSON && gcp && container) {
          step2.classList.remove('waiting', 'in-progress');
          step2.classList.add('completed');
          status2.textContent = '‚úÖ Completato';
          completedSteps++;
          totalData++;
          totalSize += JSON.stringify(stallsGeoJSON).length;
        } else if (pngTransparent && pngMeta) {
          step2.classList.remove('waiting', 'completed');
          step2.classList.add('in-progress');
          status2.textContent = '‚è≥ Pronto per iniziare';
        } else {
          step2.classList.remove('completed', 'in-progress');
          step2.classList.add('waiting');
          status2.textContent = '‚è∏Ô∏è In attesa';
        }

        // Aggiorna statistiche
        const progress = Math.round((completedSteps / 2) * 100);
        document.getElementById('stat-progress').textContent = progress + '%';
        document.getElementById('stat-steps').textContent = completedSteps + '/2';
        document.getElementById('stat-data').textContent = totalData;
        document.getElementById('stat-size').textContent = Math.round(totalSize / 1024) + ' KB';
        document.getElementById('progress-bar-fill').style.width = progress + '%';

        // Aggiorna alert
        const alert = document.getElementById('workflow-alert');
        if (completedSteps === 2) {
          alert.className = 'alert alert-success';
          alert.textContent = 'üéâ Workflow completato! Tutti i dati sono pronti.';
        } else if (completedSteps > 0) {
          alert.className = 'alert alert-info';
          alert.textContent = `‚ú® Workflow in corso... ${completedSteps} step su 2 completati.`;
        } else {
          alert.className = 'alert alert-warning';
          alert.textContent = '‚ö†Ô∏è Nessun dato nel bus. Inizia dal PNG Transparent Tool!';
        }

        // Aggiorna lista dati bus
        updateBusDataList();

        // Aggiorna preview mappa
        updateMapPreview(gcp, areaGeoJSON, hubGeoJSON, stallsGeoJSON);

      } catch (err) {
        console.error('Errore aggiornamento stato:', err);
      }
    }

    // Funzione per aggiornare lista dati nel bus
    async function updateBusDataList() {
      const container = document.getElementById('bus-data-list');
      container.innerHTML = '';

      const keys = ['png_transparent', 'png_meta', 'gcp', 'container', 'area_geojson', 'hub_geojson', 'stalls_geojson'];
      let hasData = false;

      for (const key of keys) {
        try {
          let data;
          if (key === 'png_transparent') {
            data = await DMSBUS.get(key);
          } else {
            data = await DMSBUS.getJSON(key);
          }

          if (data) {
            hasData = true;
            const item = document.createElement('div');
            item.className = 'bus-data-item';
            
            const keyDiv = document.createElement('div');
            keyDiv.className = 'bus-data-key';
            keyDiv.textContent = key;
            
            const infoDiv = document.createElement('div');
            infoDiv.className = 'bus-data-info';
            
            const size = key === 'png_transparent' 
              ? Math.round(data.length / 1024) + ' KB'
              : Math.round(JSON.stringify(data).length / 1024) + ' KB';
            
            infoDiv.innerHTML = `
              <span>‚úÖ Presente</span>
              <span>${size}</span>
            `;
            
            item.appendChild(keyDiv);
            item.appendChild(infoDiv);
            container.appendChild(item);
          }
        } catch (err) {
          // Dato non presente, skip
        }
      }

      if (!hasData) {
        container.innerHTML = '<div class="bus-data-empty">Nessun dato nel bus</div>';
      }
    }

    // Funzione per ruotare immagine con canvas
    function rotateImage(imageUrl, rotation) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // Calcola dimensioni canvas ruotato
          const rad = (rotation * Math.PI) / 180;
          const cos = Math.abs(Math.cos(rad));
          const sin = Math.abs(Math.sin(rad));
          const newWidth = img.width * cos + img.height * sin;
          const newHeight = img.width * sin + img.height * cos;
          
          canvas.width = newWidth;
          canvas.height = newHeight;
          
          // Ruota e disegna
          ctx.translate(newWidth / 2, newHeight / 2);
          ctx.rotate(rad);
          ctx.drawImage(img, -img.width / 2, -img.height / 2);
          
          // Converti in blob
          canvas.toBlob((blob) => {
            resolve(URL.createObjectURL(blob));
          }, 'image/png');
        };
        img.src = imageUrl;
      });
    }

    // Funzione per aggiornare preview mappa
    async function updateMapPreview(gcp, areaGeoJSON, hubGeoJSON, stallsGeoJSON) {
      // Rimuovi layer esistenti
      if (overlayLayer) {
        previewMap.removeLayer(overlayLayer);
        overlayLayer = null;
      }
      if (areaLayer) {
        previewMap.removeLayer(areaLayer);
        areaLayer = null;
      }
      if (hubLayer) {
        previewMap.removeLayer(hubLayer);
        hubLayer = null;
      }
      if (centerMarker) {
        previewMap.removeLayer(centerMarker);
        centerMarker = null;
      }

      // Aggiungi overlay se presente
      if (gcp && gcp.corners) {
        try {
          // Leggi PNG dal bus
          const pngBlob = await DMSBUS.getBlob('png_transparent');
          if (pngBlob) {
            // Crea URL blob
            let imageUrl = URL.createObjectURL(pngBlob);
            
            // Leggi metadata per ottenere rotazione
            const pngMeta = await DMSBUS.getJSON('png_meta');
            const rotation = pngMeta?.rotation || 0;
            
            // Se c'√® rotazione, ruota l'immagine prima
            if (rotation !== 0) {
              imageUrl = await rotateImage(imageUrl, rotation);
              console.log('üîÑ Immagine ruotata per preview:', rotation + '¬∞');
            }
            
            // Calcola bounds geografici usando min/max di TUTTI i 4 corner
            const allLats = [
              gcp.corners.nw[0],
              gcp.corners.ne[0],
              gcp.corners.se[0],
              gcp.corners.sw[0]
            ];
            const allLngs = [
              gcp.corners.nw[1],
              gcp.corners.ne[1],
              gcp.corners.se[1],
              gcp.corners.sw[1]
            ];
            
            const bounds = [
              [Math.min(...allLats), Math.min(...allLngs)],
              [Math.max(...allLats), Math.max(...allLngs)]
            ];
            
            // Crea overlay geografico
            overlayLayer = L.imageOverlay(imageUrl, bounds, {
              opacity: 0.7,
              interactive: false
            }).addTo(previewMap);
            
            // Centra mappa sull'overlay
            previewMap.fitBounds(bounds);
            
            console.log('‚úÖ Overlay geografico aggiunto alla preview mappa');
          }
        } catch (err) {
          console.error('‚ùå Errore caricamento overlay:', err);
        }
      }

      // Aggiungi area mercato
      if (areaGeoJSON) {
        areaLayer = L.geoJSON(areaGeoJSON, {
          style: {
            color: '#4CAF50',
            weight: 2,
            fillOpacity: 0.2
          }
        }).addTo(previewMap);
        previewMap.fitBounds(areaLayer.getBounds());
      }

      // Aggiungi area HUB
      if (hubGeoJSON) {
        hubLayer = L.geoJSON(hubGeoJSON, {
          style: {
            color: '#ff9800',
            weight: 2,
            fillOpacity: 0.2
          }
        }).addTo(previewMap);
      }

      // Aggiungi posteggi
      if (stallsGeoJSON) {
        L.geoJSON(stallsGeoJSON, {
          style: {
            color: '#2196F3',
            weight: 1,
            fillOpacity: 0.3
          }
        }).addTo(previewMap);
      }
      
      // Aggiungi marker centro (5¬∞ GCP)
      const container = await DMSBUS.getJSON('container');
      if (container && container.center) {
        centerMarker = L.marker(container.center.ll, {
          icon: L.divIcon({
            className: 'center-marker',
            html: '<div style="background: #FF5722; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">M</div>',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
          }),
          zIndex: 1000
        }).addTo(previewMap);
        
        centerMarker.bindPopup('<b>' + container.center.name + '</b><br>Centro mercato');
        console.log('üéØ Marker centro aggiunto alla preview');
      }
    }

    // Event listeners
    document.getElementById('btn-refresh').addEventListener('click', updateWorkflowStatus);

    document.getElementById('btn-clear-all').addEventListener('click', async () => {
      if (confirm('‚ö†Ô∏è Sei sicuro di voler cancellare TUTTI i dati dal bus?\n\nQuesta operazione non pu√≤ essere annullata!')) {
        try {
          const keys = ['png_transparent', 'png_meta', 'gcp', 'container', 'area_geojson', 'hub_geojson', 'stalls_geojson'];
          for (const key of keys) {
            await DMSBUS.deleteKey(key);
          }
          alert('‚úÖ Bus pulito con successo!');
          updateWorkflowStatus();
        } catch (err) {
          alert('‚ùå Errore durante la pulizia del bus: ' + err.message);
        }
      }
    });

    // üß™ NUOVO: Inserisci dati test
    document.getElementById('btn-test-data').addEventListener('click', async () => {
      try {
        // Dati test GeoJSON con 3 posteggi di esempio
        const testStalls = {
          "type": "FeatureCollection",
          "features": [
            {
              "type": "Feature",
              "geometry": { "type": "Point", "coordinates": [11.1117, 42.7633] },
              "properties": { "number": "A1", "kind": "alimentare", "dimensions": "4m √ó 8m" }
            },
            {
              "type": "Feature",
              "geometry": { "type": "Point", "coordinates": [11.1120, 42.7635] },
              "properties": { "number": "A2", "kind": "abbigliamento", "dimensions": "3m √ó 6m" }
            },
            {
              "type": "Feature",
              "geometry": { "type": "Point", "coordinates": [11.1115, 42.7630] },
              "properties": { "number": "B1", "kind": "artigianato", "dimensions": "5m √ó 10m" }
            }
          ]
        };
        
        const testContainer = [[42.7630, 11.1110], [42.7640, 11.1110], [42.7640, 11.1125], [42.7630, 11.1125]];
        const testGCP = [
          { pixel: [100, 100], latLng: [42.7630, 11.1110] },
          { pixel: [500, 500], latLng: [42.7640, 11.1125] }
        ];
        const testPngMeta = { width: 600, height: 600, name: "test-market.png" };
        
        await DMSBUS.putJSON('stalls_geojson', testStalls);
        await DMSBUS.putJSON('container', testContainer);
        await DMSBUS.putJSON('gcp', testGCP);
        await DMSBUS.putJSON('png_meta', testPngMeta);
        
        alert('‚úÖ Dati test inseriti con successo!\n\n3 posteggi di esempio pronti per l\'import.');
        updateWorkflowStatus();
      } catch (err) {
        alert('‚ùå Errore durante l\'inserimento dati test: ' + err.message);
      }
    });

    document.getElementById('btn-export-stalls').addEventListener('click', async () => {
      try {
        const stalls = await DMSBUS.getJSON('stalls_geojson');
        if (!stalls) {
          alert('‚ùå Nessun posteggio trovato nel BUS!\n\nCompleta prima lo Slot Editor.');
          return;
        }
        
        const blob = new Blob([JSON.stringify(stalls, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'mercato-esperanto-posteggi-' + new Date().toISOString().split('T')[0] + '.geojson';
        a.click();
        URL.revokeObjectURL(url);
        
        const count = stalls.features ? stalls.features.length : 0;
        alert('‚úÖ ' + count + ' posteggi esportati con successo!');
      } catch (err) {
        alert('‚ùå Errore durante l\'esportazione posteggi: ' + err.message);
      }
    });

    // üì§ NUOVO: Invia a DMS Hub
    document.getElementById('btn-send-to-dms').addEventListener('click', async () => {  try {
        const stallsGeoJSON = await DMSBUS.getJSON('stalls_geojson');
        const pngMeta = await DMSBUS.getJSON('png_meta');
        const gcp = await DMSBUS.getJSON('gcp');
        const container = await DMSBUS.getJSON('container');
        
        if (!stallsGeoJSON) {
          alert('‚ùå Nessun posteggio trovato nel BUS!\n\nCompleta prima lo Slot Editor.');
          return;
        }
        
        // Prepara dati per backend
        const slotEditorData = {
          stalls_geojson: stallsGeoJSON,
          png_meta: pngMeta || {},
          gcp: gcp || [],
          container: container || []
        };
        
        // Invia a backend DMS Hub
        const response = await fetch('/api/import-from-slot-editor', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ slotEditorData })
        });
        
        const result = await response.json();
        
        if (response.ok && result.success) {
          const count = stallsGeoJSON.features ? stallsGeoJSON.features.length : 0;
          alert('‚úÖ Mercato importato con successo!\n\n' + 
                'Mercato ID: ' + result.marketId + '\n' +
                'Posteggi: ' + count + '\n\n' +
                'Vai alla tab "Gestione Mercati" per vedere il risultato!');
        } else {
          alert('‚ùå Errore durante l\'import:\n\n' + (result.error || 'Errore sconosciuto'));
        }
      } catch (err) {
        console.error('Errore invio a DMS Hub:', err);
        alert('‚ùå Errore durante l\'invio a DMS Hub:\n\n' + err.message);
      }
    });

    document.getElementById('btn-export').addEventListener('click', async () => {
      try {
        const project = {};
        const keys = ['png_transparent', 'png_meta', 'gcp', 'container', 'area_geojson', 'hub_geojson', 'stalls_geojson'];
        
        for (const key of keys) {
          try {
            if (key === 'png_transparent') {
              project[key] = await DMSBUS.get(key);
            } else {
              project[key] = await DMSBUS.getJSON(key);
            }
          } catch (err) {
            // Skip missing keys
          }
        }

        const blob = new Blob([JSON.stringify(project, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'dms-project-' + new Date().toISOString().split('T')[0] + '.json';
        a.click();
        URL.revokeObjectURL(url);
        
        alert('‚úÖ Progetto esportato con successo!');
      } catch (err) {
        alert('‚ùå Errore durante l\'esportazione: ' + err.message);
      }
    });

    document.getElementById('btn-import').addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/json';
      input.onchange = async (e) => {
        try {
          const file = e.target.files[0];
          const text = await file.text();
          const project = JSON.parse(text);

          for (const [key, value] of Object.entries(project)) {
            if (key === 'png_transparent') {
              await DMSBUS.put(key, value);
            } else {
              await DMSBUS.putJSON(key, value);
            }
          }

          alert('‚úÖ Progetto importato con successo!');
          updateWorkflowStatus();
        } catch (err) {
          alert('‚ùå Errore durante l\'importazione: ' + err.message);
        }
      };
      input.click();
    });

    // ========== CHECKPOINT MANAGEMENT ==========
    
    async function saveCheckpoint(name) {
      try {
        const timestamp = new Date().toISOString();
        const checkpointId = 'checkpoint_' + Date.now();
        
        // Leggi stato attuale dal bus
        const checkpoint = {
          id: checkpointId,
          name: name || 'Checkpoint ' + new Date().toLocaleString('it-IT'),
          timestamp: timestamp,
          data: {}
        };
        
        // Salva tutti i dati dal bus (usando DMSBUS)
        const keys = ['png_transparent', 'png_meta', 'gcp', 'container', 'area_geojson', 'hub_geojson', 'stalls_geojson'];
        for (const key of keys) {
          try {
            let data;
            if (key === 'png_transparent') {
              data = await DMSBUS.get(key);
            } else {
              data = await DMSBUS.getJSON(key);
            }
            if (data) checkpoint.data[key] = data;
          } catch (err) {}
        }
        
        // Salva checkpoint in localStorage
        localStorage.setItem(checkpointId, JSON.stringify(checkpoint));
        
        // Aggiorna lista
        updateCheckpointList();
        
        return checkpointId;
      } catch (err) {
        console.error('Errore salvataggio checkpoint:', err);
        return null;
      }
    }
    
    async function loadCheckpoint(checkpointId) {
      try {
        const checkpointData = localStorage.getItem(checkpointId);
        if (!checkpointData) {
          alert('‚ùå Checkpoint non trovato!');
          return;
        }
        
        const checkpoint = JSON.parse(checkpointData);
        
        // Ripristina dati nel bus (usando DMSBUS)
        for (const [key, value] of Object.entries(checkpoint.data)) {
          try {
            if (key === 'png_transparent') {
              // Se √® una stringa base64, convertila in Blob
              if (typeof value === 'string' && value.startsWith('data:image')) {
                const response = await fetch(value);
                const blob = await response.blob();
                await DMSBUS.putBlob(key, blob);
              } else {
                await DMSBUS.put(key, value);
              }
            } else {
              await DMSBUS.putJSON(key, value);
            }
          } catch (keyErr) {
            console.error(`Errore ripristino chiave ${key}:`, keyErr);
          }
        }
        
        alert('‚úÖ Checkpoint ripristinato: ' + checkpoint.name);
        updateWorkflowStatus();
      } catch (err) {
        console.error('Errore ripristino checkpoint:', err);
        alert('‚ùå Errore ripristino checkpoint: ' + err.message);
      }
    }
    
    function deleteCheckpoint(checkpointId) {
      if (confirm('‚ö†Ô∏è Sei sicuro di voler eliminare questo checkpoint?')) {
        localStorage.removeItem(checkpointId);
        updateCheckpointList();
      }
    }
    
    function updateCheckpointList() {
      const container = document.getElementById('checkpoint-list');
      container.innerHTML = '';
      
      // Trova tutti i checkpoint
      const checkpoints = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('checkpoint_')) {
          try {
            const data = JSON.parse(localStorage.getItem(key));
            checkpoints.push(data);
          } catch (err) {}
        }
      }
      
      // Ordina per timestamp (pi√π recenti prima)
      checkpoints.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      
      if (checkpoints.length === 0) {
        container.innerHTML = '<div class="checkpoint-empty">Nessun checkpoint salvato</div>';
        return;
      }
      
      // Mostra checkpoint
      checkpoints.forEach(cp => {
        const item = document.createElement('div');
        item.className = 'checkpoint-item';
        
        const dataCount = Object.keys(cp.data).length;
        const date = new Date(cp.timestamp).toLocaleString('it-IT');
        
        item.innerHTML = `
          <div class="checkpoint-header">
            <div class="checkpoint-title">${cp.name}</div>
            <div class="checkpoint-time">${date}</div>
          </div>
          <div class="checkpoint-desc">${dataCount} dati salvati</div>
          <div class="checkpoint-actions">
            <button class="secondary" onclick="loadCheckpoint('${cp.id}')">Ripristina</button>
            <button class="danger" onclick="deleteCheckpoint('${cp.id}')">Elimina</button>
          </div>
        `;
        
        container.appendChild(item);
      });
    }
    
    // Auto-save checkpoint quando cambiano i dati
    let lastDataHash = '';
    async function autoSaveCheckpoint() {
      try {
        // Calcola hash dei dati attuali (usando DMSBUS)
        const keys = ['png_transparent', 'png_meta', 'gcp', 'container', 'area_geojson', 'hub_geojson', 'stalls_geojson'];
        let currentHash = '';
        
        for (const key of keys) {
          try {
            const data = await DMSBUS.get(key);
            if (data) {
              const dataStr = typeof data === 'string' ? data : JSON.stringify(data);
              currentHash += key + ':' + dataStr.length + ';';
            }
          } catch (err) {}
        }
        
        // Se i dati sono cambiati, salva checkpoint
        if (currentHash !== lastDataHash && currentHash !== '') {
          lastDataHash = currentHash;
          
          // Determina nome checkpoint basato su step completati
          let checkpointName = 'Auto-save';
          if (await DMSBUS.get('png_transparent')) checkpointName = 'Step 1: PNG Transparent';
          if (await DMSBUS.getJSON('gcp')) checkpointName = 'Step 2: Area Editor';
          if (await DMSBUS.getJSON('stalls_geojson')) checkpointName = 'Step 3: Slot Editor';
          
          await saveCheckpoint(checkpointName);
        }
      } catch (err) {
        console.error('Errore auto-save:', err);
      }
    }
    
    // ========== BANCA MAPPE ==========
    
    async function saveToBancaMappe() {
      try {
        // Leggi nome mercato dal DMSBUS
        let name = await DMSBUS.getJSON('market_name');
        
        // Se non c'√®, usa il nome dal campo input
        if (!name) {
          name = document.getElementById('market-name-input')?.value.trim();
        }
        
        // Se ancora non c'√®, chiedi all'utente
        if (!name) {
          name = prompt('üíæ Nome configurazione mappa:', 'Mercato ' + new Date().toLocaleDateString('it-IT'));
        }
        
        if (!name) return;
        
        const timestamp = new Date().toISOString();
        const mapId = 'map_' + Date.now();
        
        // Leggi tutti i dati dal BUS
        const mapConfig = {
          id: mapId,
          name: name,
          timestamp: timestamp,
          data: {}
        };
        
        const keys = ['png_transparent', 'png_meta', 'gcp', 'container', 'area_geojson', 'hub_geojson', 'stalls_geojson'];
        for (const key of keys) {
          try {
            let data;
            if (key === 'png_transparent') {
              data = await DMSBUS.get(key);
            } else {
              data = await DMSBUS.getJSON(key);
            }
            if (data) mapConfig.data[key] = data;
          } catch (err) {}
        }
        
        // Conta elementi
        const stats = {
          posteggi: 0,
          marker: 0,
          aree: 0
        };
        
        if (mapConfig.data.stalls_geojson?.features) {
          stats.posteggi = mapConfig.data.stalls_geojson.features.filter(f => f.properties?.type === 'parking').length;
          stats.marker = mapConfig.data.stalls_geojson.features.filter(f => f.properties?.type === 'custom_marker').length;
          stats.aree = mapConfig.data.stalls_geojson.features.filter(f => f.properties?.type === 'custom_area').length;
        }
        
        mapConfig.stats = stats;
        
        // Salva in localStorage
        localStorage.setItem(mapId, JSON.stringify(mapConfig));
        
        alert(`‚úÖ Configurazione "${name}" salvata!\n\nüéØ ${stats.posteggi} posteggi\nüìç ${stats.marker} marker\nüó∫Ô∏è ${stats.aree} aree`);
        
        updateBancaMappeList();
      } catch (err) {
        console.error('Errore salvataggio mappa:', err);
        alert('‚ùå Errore salvataggio: ' + err.message);
      }
    }
    
    async function loadFromBancaMappe(mapId) {
      try {
        const mapData = localStorage.getItem(mapId);
        if (!mapData) {
          alert('‚ùå Configurazione non trovata!');
          return;
        }
        
        const mapConfig = JSON.parse(mapData);
        
        // Ripristina dati nel BUS
        for (const [key, value] of Object.entries(mapConfig.data)) {
          try {
            if (key === 'png_transparent') {
              await DMSBUS.put(key, value);
            } else {
              await DMSBUS.putJSON(key, value);
            }
          } catch (keyErr) {
            console.error(`Errore ripristino ${key}:`, keyErr);
          }
        }
        
        alert('‚úÖ Configurazione "' + mapConfig.name + '" caricata!');
        updateWorkflowStatus();
      } catch (err) {
        console.error('Errore caricamento mappa:', err);
        alert('‚ùå Errore caricamento: ' + err.message);
      }
    }
    
    function exportFromBancaMappe(mapId) {
      try {
        const mapData = localStorage.getItem(mapId);
        if (!mapData) {
          alert('‚ùå Configurazione non trovata!');
          return;
        }
        
        const mapConfig = JSON.parse(mapData);
        
        const blob = new Blob([JSON.stringify(mapConfig, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'dms-map-' + mapConfig.name.replace(/[^a-z0-9]/gi, '-').toLowerCase() + '.json';
        a.click();
        URL.revokeObjectURL(url);
        
        alert('‚úÖ Configurazione esportata!');
      } catch (err) {
        console.error('Errore esportazione:', err);
        alert('‚ùå Errore esportazione: ' + err.message);
      }
    }
    
    function deleteFromBancaMappe(mapId) {
      try {
        const mapData = localStorage.getItem(mapId);
        if (!mapData) return;
        
        const mapConfig = JSON.parse(mapData);
        
        if (confirm('‚ö†Ô∏è Eliminare "' + mapConfig.name + '"?\n\nQuesta operazione non pu√≤ essere annullata!')) {
          localStorage.removeItem(mapId);
          updateBancaMappeList();
          alert('‚úÖ Configurazione eliminata!');
        }
      } catch (err) {
        console.error('Errore eliminazione:', err);
        alert('‚ùå Errore eliminazione: ' + err.message);
      }
    }
    
    function updateBancaMappeList() {
      const container = document.getElementById('saved-maps-list');
      container.innerHTML = '';
      
      // Trova tutte le mappe salvate
      const maps = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('map_')) {
          try {
            const data = JSON.parse(localStorage.getItem(key));
            maps.push(data);
          } catch (err) {}
        }
      }
      
      // Ordina per timestamp (pi√π recenti prima)
      maps.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      
      if (maps.length === 0) {
        container.innerHTML = '<div style="text-align: center; opacity: 0.6; padding: 20px; font-size: 13px;">Nessuna configurazione salvata</div>';
        return;
      }
      
      // Mostra mappe
      maps.forEach(map => {
        const item = document.createElement('div');
        item.style.cssText = 'background: #1a4a5a; padding: 12px; margin-bottom: 8px; border-radius: 6px; border-left: 3px solid #4fc3a0;';
        
        const date = new Date(map.timestamp).toLocaleString('it-IT');
        const stats = map.stats || { posteggi: 0, marker: 0, aree: 0 };
        
        item.innerHTML = `
          <div style="font-weight: 600; margin-bottom: 4px; font-size: 14px;">üó∫Ô∏è ${map.name}</div>
          <div style="font-size: 12px; opacity: 0.7; margin-bottom: 8px;">üìÖ ${date}</div>
          <div style="font-size: 12px; margin-bottom: 8px; display: flex; gap: 12px;">
            <span>üéØ ${stats.posteggi} posteggi</span>
            <span>üìç ${stats.marker} marker</span>
            <span>üó∫Ô∏è ${stats.aree} aree</span>
          </div>
          <div style="display: flex; gap: 6px; flex-wrap: wrap;">
            <button class="btn secondary" onclick="loadFromBancaMappe('${map.id}')" style="flex: 1; min-width: 80px; padding: 6px 10px; font-size: 12px;">üîÑ Carica</button>
            <button class="btn secondary" onclick="exportFromBancaMappe('${map.id}')" style="flex: 1; min-width: 80px; padding: 6px 10px; font-size: 12px;">üìÑ Esporta</button>
            <button class="btn danger" onclick="deleteFromBancaMappe('${map.id}')" style="padding: 6px 10px; font-size: 12px;">üóëÔ∏è</button>
          </div>
        `;
        
        container.appendChild(item);
      });
    }
    
    // Event listeners Banca Mappe
    document.getElementById('btn-save-map').addEventListener('click', saveToBancaMappe);
    
    document.getElementById('btn-load-map').addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/json';
      input.onchange = async (e) => {
        try {
          const file = e.target.files[0];
          const text = await file.text();
          const mapConfig = JSON.parse(text);
          
          // Verifica struttura
          if (!mapConfig.data) {
            alert('‚ùå File non valido: manca la struttura dati!');
            return;
          }
          
          // Ripristina nel BUS
          for (const [key, value] of Object.entries(mapConfig.data)) {
            try {
              if (key === 'png_transparent') {
                await DMSBUS.put(key, value);
              } else {
                await DMSBUS.putJSON(key, value);
              }
            } catch (keyErr) {
              console.error(`Errore ripristino ${key}:`, keyErr);
            }
          }
          
          // Salva anche in Banca Mappe
          const mapId = 'map_' + Date.now();
          mapConfig.id = mapId;
          localStorage.setItem(mapId, JSON.stringify(mapConfig));
          
          alert('‚úÖ Configurazione "' + (mapConfig.name || 'Importata') + '" caricata e salvata!');
          updateWorkflowStatus();
          updateBancaMappeList();
        } catch (err) {
          console.error('Errore importazione:', err);
          alert('‚ùå Errore importazione: ' + err.message);
        }
      };
      input.click();
    });
    
    // Event listeners checkpoint
    document.getElementById('btn-save-checkpoint').addEventListener('click', async () => {
      const name = prompt('üíæ Nome checkpoint:', 'Checkpoint manuale ' + new Date().toLocaleTimeString('it-IT'));
      if (name) {
        await saveCheckpoint(name);
        alert('‚úÖ Checkpoint salvato!');
      }
    });
    
    // Aggiorna stato all'avvio
    updateWorkflowStatus();
    updateCheckpointList();
    updateBancaMappeList();

    // Auto-refresh ogni 30 secondi
    setInterval(() => {
      updateWorkflowStatus();
      autoSaveCheckpoint();
    }, 30000);

    // Funzione per aprire Slot Editor v3 con PNG in localStorage
    async function goToSlotEditorV3() {
      try {
        // Verifica se DMSBUS √® disponibile
        if (typeof DMSBUS === 'undefined' || !DMSBUS.getBlob) {
          alert('‚ö†Ô∏è DMSBUS non disponibile. Carica prima un PNG nel PNG Transparent Tool.');
          return;
        }

        // Carica PNG trasparente dal BUS
        const pngTransparent = await DMSBUS.getBlob('png_transparent');
        if (!pngTransparent) {
          alert('‚ö†Ô∏è Nessun PNG trasparente trovato nel BUS. Usa prima il PNG Transparent Tool.');
          return;
        }

        // Carica PNG originale dal BUS
        const pngOriginal = await DMSBUS.getBlob('png_original');
        
        // Carica GCP (Ground Control Points) per bounds
        const gcp = await DMSBUS.getJSON('gcp');

        // Converti PNG trasparente in Base64
        const readerTransparent = new FileReader();
        readerTransparent.onloadend = async () => {
          const base64Transparent = readerTransparent.result;
          
          // Salva PNG trasparente in localStorage
          localStorage.setItem('plant_png_transparent_base64', base64Transparent);
          localStorage.setItem('plant_png_timestamp', Date.now().toString());
          
          // Salva GCP (bounds) in localStorage se disponibile
          if (gcp) {
            localStorage.setItem('plant_gcp', JSON.stringify(gcp));
            console.log('‚úÖ GCP salvato (bounds per overlay)');
          }
          
          console.log('‚úÖ PNG trasparente salvato (' + Math.round(base64Transparent.length / 1024) + ' KB)');
          
          // Se c'√® anche l'originale, salvalo
          if (pngOriginal) {
            const readerOriginal = new FileReader();
            readerOriginal.onloadend = () => {
              const base64Original = readerOriginal.result;
              localStorage.setItem('plant_png_original_base64', base64Original);
              console.log('‚úÖ PNG originale salvato (' + Math.round(base64Original.length / 1024) + ' KB)');
              
              // Apri Slot Editor v3
              window.location.href = 'slot_editor_v3_unified.html';
            };
            readerOriginal.readAsDataURL(pngOriginal);
          } else {
            console.log('‚ö†Ô∏è PNG originale non trovato nel BUS');
            // Apri comunque Slot Editor v3
            window.location.href = 'slot_editor_v3_unified.html';
          }
        };
        readerTransparent.readAsDataURL(pngTransparent);
        
      } catch (err) {
        console.error('‚ùå Errore:', err);
        alert('‚ùå Errore durante il caricamento del PNG: ' + err.message);
      }
    }
    
    // Salva nome mercato nel DMSBUS quando si clicca sui tool
    document.getElementById('btn-png-tool').addEventListener('click', async (e) => {
      const marketName = document.getElementById('market-name-input').value.trim();
      if (marketName) {
        try {
          await DMSBUS.putJSON('market_name', marketName);
          console.log('‚úÖ Nome mercato salvato:', marketName);
        } catch (err) {
          console.error('‚ùå Errore salvataggio nome mercato:', err);
        }
      }
    });
    
    document.getElementById('btn-slot-editor').addEventListener('click', async (e) => {
      const marketName = document.getElementById('market-name-input').value.trim();
      if (marketName) {
        try {
          await DMSBUS.putJSON('market_name', marketName);
          console.log('‚úÖ Nome mercato salvato:', marketName);
        } catch (err) {
          console.error('‚ùå Errore salvataggio nome mercato:', err);
        }
      }
    });
    
    // Carica nome mercato dal DMSBUS all'avvio
    (async () => {
      try {
        const savedName = await DMSBUS.getJSON('market_name');
        if (savedName) {
          document.getElementById('market-name-input').value = savedName;
        }
      } catch (err) {
        console.error('Errore caricamento nome mercato:', err);
      }
    })();
  </script>
</body>
</html>

